<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Trái tim 3D & Tên bằng sao ✨</title>
  <style>
    html, body { height:100%; margin:0; background:#010104; overflow:hidden; }
    #scene{ width:100%; height:100%; display:block; }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    const NAME = "VÂN KHÁNH";

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('scene'), antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0,0,1000);
    function onResize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
    addEventListener('resize', onResize); onResize();

    // star texture
    function makeTex(color){
      const c=document.createElement('canvas'); c.width=c.height=64; const ctx=c.getContext('2d');
      const g=ctx.createRadialGradient(32,32,0,32,32,32);
      g.addColorStop(0,color); g.addColorStop(0.3,color); g.addColorStop(1,'transparent');
      ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
      return new THREE.CanvasTexture(c);
    }
    const texWhite=makeTex('#ffffff');
    const texRed=makeTex('#ff1a1a');

    // background stars
    (function(){
      const count=6000, radius=3500; const pos=new Float32Array(count*3);
      for(let i=0;i<count;i++){
        const r=radius*Math.cbrt(Math.random());
        const th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
        pos[i*3]=r*Math.sin(ph)*Math.cos(th);
        pos[i*3+1]=r*Math.sin(ph)*Math.sin(th);
        pos[i*3+2]=r*Math.cos(ph);
      }
      const g=new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const m=new THREE.PointsMaterial({ map:texWhite, size:1.2, transparent:true, depthWrite:false, opacity:0.9 });
      scene.add(new THREE.Points(g,m));
    })();

    // heart 3D explicit parametric sampling
    // sử dụng công thức tham số để tạo bề mặt trái tim 3D
    function heart3DPoints(n){
      const pts=new Float32Array(n*3);
      for(let i=0;i<n;i++){
        const u=Math.random()*Math.PI*2;
        const v=Math.random()*Math.PI;
        const r=1 - Math.sin(v);
        const x=r*Math.cos(u);
        const y=r*Math.sin(u);
        const z=Math.cos(v);
        pts[i*3]=x*200;
        pts[i*3+1]=y*200+150;
        pts[i*3+2]=z*200;
      }
      return pts;
    }

    const heartPos=heart3DPoints(25000);
    const heartGeom=new THREE.BufferGeometry(); heartGeom.setAttribute('position', new THREE.BufferAttribute(heartPos,3));
    const heartMat=new THREE.PointsMaterial({ map:texRed, size:2.2, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, opacity:1 });
    const heart=new THREE.Points(heartGeom,heartMat);
    scene.add(heart);

    // text points
    function textPoints(text){
      const W=1600,H=400; const c=document.createElement('canvas'); c.width=W; c.height=H; const ctx=c.getContext('2d');
      ctx.fillStyle='#fff'; ctx.font='900 240px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text,W/2,H/2);
      const img=ctx.getImageData(0,0,W,H).data; const pts=[];
      for(let y=0;y<H;y+=3){ for(let x=0;x<W;x+=3){ if(img[(y*W+x)*4+3]>128) pts.push([(x-W/2)*0.7,(H/2-y)*0.7-250]); } }
      const arr=new Float32Array(pts.length*3);
      for(let i=0;i<pts.length;i++){ arr[i*3]=pts[i][0]; arr[i*3+1]=pts[i][1]; arr[i*3+2]=(Math.random()-.5)*20; }
      return arr;
    }
    const namePos=textPoints(NAME);
    const nameGeom=new THREE.BufferGeometry(); nameGeom.setAttribute('position', new THREE.BufferAttribute(namePos,3));
    const nameMat=new THREE.PointsMaterial({ map:texWhite, size:2.0, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false });
    const nameMesh=new THREE.Points(nameGeom,nameMat);
    scene.add(nameMesh);

    // animation
    const t0=performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const t=(performance.now()-t0)/1000;
      const beat=1+0.07*Math.sin(t*3);
      heart.scale.setScalar(beat);
      renderer.render(scene,camera);
    }
    animate();
  </script>
</body>
</html>
